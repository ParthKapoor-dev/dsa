
# Minimize Maximum Vulnerability (LeetCode-style)

You are given an array `vulnerability` of length `n`, where `vulnerability[i]` is the vulnerability value of the `i`â€‘th server.  
You must **select exactly `k` servers** such that **no two selected servers are adjacent**.  
The **vulnerability of the selection** is defined as the **maximum value** among the selected servers.

Return the **minimum possible vulnerability** over all valid selections.

---

## Examples

**Example 1**

```
Input:  vulnerability = [2,3,5,9], k = 2
Output: 5
Explanation:
Valid non-adjacent pairs are [2,5], [2,9], [3,9] with maxima 5, 9, 9 respectively.
The minimum maximum is 5.
```

**Example 2**

```
Input:  vulnerability = [2,4,6,8,10], k = 2
Output: 6
```

**Example 3**

```
Input:  vulnerability = [1,2,1,2,1], k = 3
Output: 1
Explanation: Pick positions [0,2,4].
```

---

## Constraints

- `1 <= n <= 1e5`
- `1 <= vulnerability[i] <= 1e9`
- `1 <= k <= (n+1)/2` (ensures that selecting `k` non-adjacent elements is possible)

---

## Intuition

We want to **minimize the maximum** element among the chosen non-adjacent elements. This suggests **binary searching** the answer on a threshold `T`:

> *Can we choose at least `k` non-adjacent elements such that every chosen value is `<= T`?*

If **yes**, then the true answer is `<= T`, so we can lower the search range. If **no**, we must raise it.

To check feasibility for a fixed `T`, greedily scan the array and pick an index whenever `vulnerability[i] <= T`, then skip the next index to satisfy the non-adjacent constraint. To avoid parity artifacts, try starting from index `0` and index `1` and take the better count.

---

## Algorithm

1. Set `lo = min(vulnerability)`, `hi = max(vulnerability)`.
2. While `lo < hi`:
   - `mid = (lo + hi) / 2`.
   - If `canPickK(mid)` is true, set `hi = mid`; else set `lo = mid + 1`.
3. Return `lo`.

`canPickK(T)`:
- Count maximum picks with values `<= T` using a greedy pass, once starting from index `0`, once from `1`.
- Return whether the best count is at least `k`.

---

## Correctness Sketch

For a fixed threshold `T`, any feasible solution may only choose indices with value `<= T`. Among these indices, the constraint is just "choose `k` non-adjacent indices". The greedy pass that always picks the earliest available acceptable index yields a maximal independent set on a path, so it produces the maximum number of picks for that `T`. Trying both parities accounts for the first pick possibly being better from index `1` than index `0`. Therefore, `canPickK(T)` is correct. Binary search over `T` then finds the minimum `T` for which feasibility holds.

---

## Complexity

- `canPickK(T)` runs in `O(n)`.
- Binary search over the value range (up to `1e9`) takes `~30` iterations.
- **Total:** `O(n log 1e9)` time, `O(1)` extra space.

---

## Reference Implementation (C++17)

See `min_vulnerability.cpp` in this folder. The `main()` includes a rich set of test cases and prints a pass/fail summary, similar to a LeetCode judge.
