#include <bits/stdc++.h>
#include <algorithm>
#include <chrono>
using namespace std;

/*
   Problem:
   Select exactly k non-adjacent elements from an array "vulnerability".
   The "vulnerability" of a chosen set is the maximum value in that set.
   Return the minimum possible vulnerability over all valid selections.
*/

class Solution {
public:


bool canSelect(vector<long long>& vulnerability, int k, int maxVul) {
    int selected = 0;
    int i = 0;
    int n = vulnerability.size();
    
    while (i < n && selected < k) {
        if (vulnerability[i] <= maxVul) {
            selected++;
            i += 2; // Skip next element (non-adjacent constraint)
        } else {
            i++;
        }
    }
    
    return selected >= k;
}

long getMinVulnerability(vector<long long> vulnerability, int k) {
    int left = *min_element(vulnerability.begin(), vulnerability.end());
    int right = *max_element(vulnerability.begin(), vulnerability.end());
    int result = right;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canSelect(vulnerability, k, mid)) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return result;
}
};

// ---------------------- TEST HARNESS ----------------------
struct TestCase {
    vector<long long> vulnerability;
    int k;
    long long expected;
    string name;
    bool checkExpected;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    Solution sol;

    // time cutoff (ms) for "TLE"
    const long long TLE_LIMIT_MS = 800;  

    vector<TestCase> tests = {
        // From prompt images / examples
        {{2, 3, 5, 9}, 2, 5, "Example: [2,3,5,9], k=2 -> 5", true},
        {{2, 4, 6, 8, 10}, 2, 6, "Sample-0: [2,4,6,8,10], k=2 -> 6", true},
        {{1, 2, 1, 2, 1}, 3, 1, "Sample-1: [1,2,1,2,1], k=3 -> 1", true},

        // Basic sanity
        {{42}, 1, 42, "Single element", true},
        {{5, 1, 9}, 1, 1, "k=1 picks minimum", true},
        {{7, 7, 7, 7}, 2, 7, "All equal", true},

        // Parity / adjacency tricky
        {{3, 100, 4, 100, 5}, 2, 4, "Alternating highs with smalls", true},
        {{10, 1, 10, 1, 10}, 2, 1, "Pick the two 1s", true},

        // Choose many (max picks)
        {{5,100,5,100,5,100,5}, 4, 5, "Max non-adjacent picks of 5s", true},

        // Edge-ish patterns
        {{5,4,3,2,1}, 2, 3, "Descending - choose (3,1) -> 3", true},
        {{1,100,1,100,1}, 3, 1, "Odd positions small - pick all smalls", true},
        {{1000000000LL, 1, 1000000000LL, 1}, 2, 1, "Large values within bounds", true},
        {{2, 1, 2, 1, 2, 1, 2}, 3, 1, "Many small 1s available", true},
        {{9, 8, 7, 6, 5, 4}, 3, 8, "Descending - best triple is (1,3,5) -> 8", true},

        // Additional validation where greedy parity matters
        {{8, 5, 6, 5, 8}, 2, 5, "Middle pair yields 5", true},
        {{5, 1, 1, 1, 5}, 2, 1, "Pick two middle 1s", true},

        // ---- Heavy Stress Cases where recursion should blow up (expect TLE) ----
        ([](){ vector<long long> v(25, 7); return TestCase{v, 12, -1, "Stress: n=25, k=12 (Exponential)", false}; })(),
        ([](){ vector<long long> v(28, 3); return TestCase{v, 14, -1, "Stress: n=28, k=14 (Exponential)", false}; })(),
        ([](){ vector<long long> v(30, 5); return TestCase{v, 15, -1, "Stress: n=30, k=15 (Exponential)", false}; })(),
        ([](){ vector<long long> v(35, 1); return TestCase{v, 17, -1, "Stress: n=35, k=17 (Exponential)", false}; })(),
    };

    int passed = 0, total = (int)tests.size();
    for (size_t i = 0; i < tests.size(); ++i) {
        auto &t = tests[i];

        auto start = chrono::high_resolution_clock::now();
        long long got = sol.getMinVulnerability(t.vulnerability, t.k);
        auto end = chrono::high_resolution_clock::now();

        long long elapsed_ms = chrono::duration_cast<chrono::milliseconds>(end - start).count();

        if (elapsed_ms > TLE_LIMIT_MS) {
            cout << "Test " << (i+1) << " - " << t.name 
                 << ": TLE (>" << TLE_LIMIT_MS << "ms)\n";
            continue;
        }

        if (t.checkExpected) {
            bool ok = (got == t.expected);
            cout << "Test " << (i+1) << " - " << t.name << ": expected " 
                 << t.expected << ", got " << got << " -> " 
                 << (ok ? "PASS" : "FAIL") << " (" << elapsed_ms << "ms)\n";
            if (ok) passed++;
        } else {
            cout << "Test " << (i+1) << " - " << t.name 
                 << ": executed in " << elapsed_ms << "ms (expected TLE in bigger n)\n";
        }
    }

    cout << "\nSummary: " << passed << "/" << total << " tests passed (others were TLE checks).\n";
    return 0;
}
